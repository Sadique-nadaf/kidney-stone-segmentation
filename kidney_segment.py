# -*- coding: utf-8 -*-
"""kidney_segment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/111gTFZtu2FO9UMag8ror2XZpiY_QsnP1
"""

from google.colab.patches import cv2_imshow

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Read image
img = cv2.imread('/content/Stone- (1000).jpg')

plt.imshow(img)
plt.show()

# Cropping an image
cropped_image = img[230:320, 130:200]

# Display cropped image
cv2_imshow( cropped_image)

# Save the cropped image
cv2.imwrite("Cropped Image.jpg", cropped_image)

cropped_image2 = img[230:320, 320:390]
# Display cropped image
cv2_imshow( cropped_image2)

# Save the cropped image
cv2.imwrite("Cropped Image_2.jpg", cropped_image2)

"""# STONE PRESENT

LEFT KIDNEY
"""

import cv2
import numpy as np
from matplotlib import pyplot as plt

image = cv2.imread('/content/Stone- (1000).jpg')
cropped_image = img[230:320, 130:200]
plt.imshow(cv2.cvtColor(cropped_image, cv2.COLOR_BGR2RGB))
plt.title('Cropped Image')
plt.show()

#grayscale
image_gray = cv2.cvtColor(cropped_image, cv2.COLOR_BGR2GRAY)
plt.imshow(image_gray, 'gray')
plt.title('Grayscale Image')
plt.show()

# Apply median filter
median_filtered = cv2.medianBlur(image_gray, 3)
plt.imshow(median_filtered, 'gray')
plt.title('Median Filtered')
plt.show()

# 2x7 smoothing matrix
smoothing_matrix = np.array([[1, 1, 1, 1, 1, 1, 1],
                             [0, 0, 0, 0, 0, 0, 0]], dtype=np.float32)

# Normalize matrix
smoothing_matrix /= smoothing_matrix.sum()

# Apply smoothing matrix
smoothed = cv2.filter2D(median_filtered, -1, smoothing_matrix)
plt.imshow(smoothed, 'gray')
plt.title('Smoothed')
plt.show()

# Apply top-hat filter
kernel_size = (10, 10)
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, kernel_size)
top_hat_filtered = cv2.morphologyEx(smoothed, cv2.MORPH_TOPHAT, kernel)
plt.imshow(top_hat_filtered, 'gray')
plt.title('Top-hat Filtered')
plt.show()

# Image binarization
_, binarized = cv2.threshold(top_hat_filtered, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
plt.imshow(binarized, 'gray')
plt.title('Binarized')
plt.show()

# Morphological operations
kernel = np.ones((3, 3), np.uint8)
eroded = cv2.erode(binarized, kernel, iterations=1)
plt.imshow(eroded, 'gray')
plt.title('Eroded')
plt.show()
dilated = cv2.dilate(eroded, kernel, iterations=1)
plt.imshow(dilated, 'gray')
plt.title('Dilated')
plt.show()

#watershed
dist_transform = cv2.distanceTransform(dilated, cv2.DIST_L2, 5)
ret, sure_fg = cv2.threshold(dist_transform, 0.7 * dist_transform.max(), 255, 0)

sure_bg = cv2.dilate(dilated, kernel, iterations=3)

sure_fg = np.uint8(sure_fg)
unknown = cv2.subtract(sure_bg, sure_fg)

ret, markers = cv2.connectedComponents(sure_fg)

markers = markers + 1

markers[unknown == 255] = 0

# Apply watershed
markers = cv2.watershed(cropped_image, markers)
cropped_image[markers == -1] = [255, 0, 0]
plt.imshow(cv2.cvtColor(cropped_image, cv2.COLOR_BGR2RGB))
plt.title('Watershed Result')
plt.show()

if len(cropped_image.shape) == 3:
    image_gray = cv2.cvtColor(cropped_image, cv2.COLOR_BGR2GRAY)
else:
    image_gray = cropped_image

median_filtered = cv2.medianBlur(image_gray, 3)

# Convert image to float32
Z = median_filtered.reshape((-1, 1))
Z = np.float32(Z)

# Define criteria
criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)
K = 4  # Number of clusters
ret, label, center = cv2.kmeans(Z, K, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)


center = np.uint8(center)
res = center[label.flatten()]
res2 = res.reshape((median_filtered.shape))

plt.imshow(res2, 'gray')
plt.title('K-means Clustering')
plt.show()

label = label.reshape(median_filtered.shape)

# Splitting into different layers
layer1 = np.zeros_like(median_filtered)
layer2 = np.zeros_like(median_filtered)
layer3 = np.zeros_like(median_filtered)
layer4 = np.zeros_like(median_filtered)

layer1[label == 0] = 255
layer2[label == 1] = 255
layer3[label == 2] = 255
layer4[label == 3] = 255

# Display each layer
fig, axs = plt.subplots(1, 4, figsize=(20, 5))
axs[0].imshow(layer1, 'gray')
axs[0].set_title('Layer 1')
axs[1].imshow(layer2, 'gray')
axs[1].set_title('Layer 2')
axs[2].imshow(layer3, 'gray')
axs[2].set_title('Layer 3')
axs[3].imshow(layer4, 'gray')
plt.setp(axs, xticks=[], yticks=[])
axs[3].set_title('Layer 4')
plt.show()
combined_layers = layer1 + layer2 + layer3 + layer4
binary_mask = np.where(combined_layers > 0, 1, 0).astype(np.uint8)
masked_image = cv2.bitwise_and(cropped_image, cropped_image, mask=binary_mask)

#final masked image
plt.imshow(cv2.cvtColor(masked_image, cv2.COLOR_BGR2RGB))
plt.title('Binary Mask Applied')
plt.show()

"""# New image"""

img2 = cv2.imread('/content/Stone- (1011).jpg')

plt.imshow(img)
plt.show()

cropped_image2 = img2[330:450, 450:550]

cv2_imshow( cropped_image2)

cv2.imwrite("Cropped Image.jpg", cropped_image2)

# Convert cropped image to grayscale
image_gray = cv2.cvtColor(cropped_image2, cv2.COLOR_BGR2GRAY)
plt.imshow(image_gray, 'gray')
plt.title('Grayscale Image')
plt.show()

# Apply median filter
median_filtered = cv2.medianBlur(image_gray, 3)
plt.imshow(median_filtered, 'gray')
plt.title('Median Filtered')
plt.show()

# Define the 2x7 smoothing matrix
smoothing_matrix = np.array([[1, 1, 1, 1, 1, 1, 1],
                             [0, 0, 0, 0, 0, 0, 0]], dtype=np.float32)

# Normalize the smoothing matrix
smoothing_matrix /= smoothing_matrix.sum()

# Apply smoothing using the custom 2x7 matrix
smoothed = cv2.filter2D(median_filtered, -1, smoothing_matrix)
plt.imshow(smoothed, 'gray')
plt.title('Smoothed')
plt.show()

# Apply top-hat filter to remove noise from the foreground
kernel_size = (10, 10)  # Adjust the kernel size based on your needs
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, kernel_size)
top_hat_filtered = cv2.morphologyEx(smoothed, cv2.MORPH_TOPHAT, kernel)
plt.imshow(top_hat_filtered, 'gray')
plt.title('Top-hat Filtered')
plt.show()

# Image binarization
_, binarized = cv2.threshold(top_hat_filtered, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
plt.imshow(binarized, 'gray')
plt.title('Binarized')
plt.show()

# Morphological operations: Erosion followed by Dilation
kernel = np.ones((3, 3), np.uint8)
eroded = cv2.erode(binarized, kernel, iterations=1)
plt.imshow(eroded, 'gray')
plt.title('Eroded')
plt.show()

dilated = cv2.dilate(eroded, kernel, iterations=1)
plt.imshow(dilated, 'gray')
plt.title('Dilated')
plt.show()

# Distance transform and thresholding for watershed
dist_transform = cv2.distanceTransform(dilated, cv2.DIST_L2, 5)
ret, sure_fg = cv2.threshold(dist_transform, 0.7 * dist_transform.max(), 255, 0)

# Finding sure background
sure_bg = cv2.dilate(dilated, kernel, iterations=3)

# Finding unknown region
sure_fg = np.uint8(sure_fg)
unknown = cv2.subtract(sure_bg, sure_fg)

# Marker labelling
ret, markers = cv2.connectedComponents(sure_fg)

# Add one to all labels so that sure background is not 0, but 1
markers = markers + 1

# Mark the unknown region with zero
markers[unknown == 255] = 0

# Apply watershed
markers = cv2.watershed(cropped_image2, markers)
cropped_image2[markers == -1] = [255, 0, 0]

# Display the result of watershed
plt.imshow(cv2.cvtColor(cropped_image2, cv2.COLOR_BGR2RGB))
plt.title('Watershed Result')
plt.show()